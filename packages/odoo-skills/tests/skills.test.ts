/**
 * Unit tests for SKILL definitions and generation
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { skillRegistry, getSkillsByLevel, getAllSkillIds } from '../src/registry';
import { MarkdownGenerator } from '../src/generator';
import { SkillDefinition } from '../src/types';

describe('SKILL Registry', () => {
  it('should have skills registered', () => {
    expect(skillRegistry.skills.length).toBeGreaterThan(0);
  });

  it('should have all skill levels represented', () => {
    const byLevel = getSkillsByLevel();

    expect(byLevel.elementary.length).toBeGreaterThan(0);
    expect(byLevel.user.length).toBeGreaterThan(0);
    expect(byLevel.admin.length).toBeGreaterThan(0);
  });

  it('should find skill by ID', () => {
    const skill = skillRegistry.get('odoo-connect');
    expect(skill).toBeDefined();
    expect(skill?.id).toBe('odoo-connect');
  });

  it('should return undefined for unknown skill', () => {
    const skill = skillRegistry.get('unknown-skill');
    expect(skill).toBeUndefined();
  });

  it('should get skills by level', () => {
    const elementary = skillRegistry.getByLevel('elementary');
    expect(elementary.every((s) => s.level === 'elementary')).toBe(true);
  });

  it('should get skills by category', () => {
    const connection = skillRegistry.getByCategory('connection');
    expect(connection.every((s) => s.category === 'connection')).toBe(true);
  });

  it('should return all skill IDs', () => {
    const ids = getAllSkillIds();
    expect(ids).toContain('odoo-connect');
    expect(ids).toContain('odoo-introspect');
    expect(ids).toContain('odoo-create-lead');
  });
});

describe('SKILL Definitions', () => {
  let allSkills: SkillDefinition[];

  beforeAll(() => {
    allSkills = skillRegistry.skills;
  });

  it('should have unique IDs', () => {
    const ids = allSkills.map((s) => s.id);
    const uniqueIds = new Set(ids);
    expect(uniqueIds.size).toBe(ids.length);
  });

  it('should have required fields', () => {
    for (const skill of allSkills) {
      expect(skill.id).toBeTruthy();
      expect(skill.shortName).toBeTruthy();
      expect(skill.title).toBeTruthy();
      expect(skill.summary).toBeTruthy();
      expect(skill.description).toBeTruthy();
      expect(skill.level).toBeTruthy();
      expect(skill.category).toBeTruthy();
      expect(Array.isArray(skill.parameters)).toBe(true);
      expect(Array.isArray(skill.examples)).toBe(true);
      expect(Array.isArray(skill.tags)).toBe(true);
    }
  });

  it('should have at least one example', () => {
    for (const skill of allSkills) {
      expect(skill.examples.length).toBeGreaterThan(0);
    }
  });

  it('should have valid examples with code', () => {
    for (const skill of allSkills) {
      for (const example of skill.examples) {
        expect(example.title).toBeTruthy();
        expect(example.description).toBeTruthy();
        expect(example.code).toBeTruthy();
        expect(typeof example.tested).toBe('boolean');
      }
    }
  });

  it('should have IDs starting with odoo-', () => {
    for (const skill of allSkills) {
      expect(skill.id.startsWith('odoo-')).toBe(true);
    }
  });

  it('should have valid related skills', () => {
    const allIds = new Set(allSkills.map((s) => s.id));

    for (const skill of allSkills) {
      for (const relatedId of skill.relatedSkills) {
        expect(allIds.has(relatedId)).toBe(true);
      }
    }
  });
});

describe('Markdown Generator', () => {
  let generator: MarkdownGenerator;

  beforeAll(() => {
    generator = new MarkdownGenerator();
  });

  it('should generate markdown for a skill', () => {
    const skill = skillRegistry.get('odoo-connect');
    expect(skill).toBeDefined();

    const markdown = generator.generate(skill!);

    expect(markdown).toContain('# /odoo-connect');
    expect(markdown).toContain('## Level');
    expect(markdown).toContain('## Prerequisites');
    expect(markdown).toContain('## Parameters');
    expect(markdown).toContain('## Usage');
    expect(markdown).toContain('```typescript');
    expect(markdown).toContain('Generated by @odoo-toolbox/skills');
  });

  it('should include all examples', () => {
    const skill = skillRegistry.get('odoo-connect');
    const markdown = generator.generate(skill!);

    for (const example of skill!.examples) {
      expect(markdown).toContain(example.title);
    }
  });

  it('should include parameters table', () => {
    const skill = skillRegistry.get('odoo-connect');
    const markdown = generator.generate(skill!);

    expect(markdown).toContain('| Parameter |');
    expect(markdown).toContain('| `url` |');
  });

  it('should include related skills', () => {
    const skill = skillRegistry.get('odoo-connect');
    const markdown = generator.generate(skill!);

    expect(markdown).toContain('## Related SKILLs');
    for (const related of skill!.relatedSkills) {
      expect(markdown).toContain(`\`/${related}\``);
    }
  });

  it('should include Odoo references', () => {
    const skill = skillRegistry.get('odoo-connect');
    const markdown = generator.generate(skill!);

    if (skill!.odooReferences.length > 0) {
      expect(markdown).toContain('## Odoo Source References');
    }
  });

  it('should show tested badge for tested examples', () => {
    const generator = new MarkdownGenerator({ showTestedBadge: true });
    const skill = skillRegistry.get('odoo-connect');
    const markdown = generator.generate(skill!);

    expect(markdown).toContain('âœ“ This example is tested');
  });
});

describe('SKILL Code Examples', () => {
  it('should have syntactically valid TypeScript in examples', () => {
    // This is a basic check - actual syntax validation happens at runtime
    for (const skill of skillRegistry.skills) {
      for (const example of skill.examples) {
        // Check for common patterns
        expect(example.code).toContain('import');
        expect(example.code).toContain('OdooClient');
        expect(example.code).toContain('await');
      }
    }
  });

  it('should include cleanup in examples that create records', () => {
    const createSkills = skillRegistry.skills.filter(
      (s) =>
        s.id.includes('create') ||
        s.examples.some((e) => e.code.includes('.create('))
    );

    for (const skill of createSkills) {
      const creatingExamples = skill.examples.filter((e) =>
        e.code.includes('.create(')
      );

      for (const example of creatingExamples) {
        // Should either have cleanup or be explicitly about not cleaning up
        const hasCleanup =
          example.code.includes('.unlink(') ||
          example.code.includes('cleanup') ||
          example.description.toLowerCase().includes('no cleanup');

        expect(hasCleanup).toBe(true);
      }
    }
  });
});
